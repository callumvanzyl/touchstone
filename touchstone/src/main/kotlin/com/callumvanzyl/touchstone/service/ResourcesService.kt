package com.callumvanzyl.touchstone.service

import com.callumvanzyl.touchstone.exception.InvalidOperationException
import com.callumvanzyl.touchstone.util.Outcome
import com.fasterxml.jackson.databind.ObjectMapper
import java.io.File
import java.nio.file.Path
import java.nio.file.Paths
import kotlin.io.path.ExperimentalPathApi
import kotlin.io.path.Path
import kotlin.io.path.createTempDirectory
import kotlin.io.path.writeBytes
import org.apache.commons.io.IOUtils
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Service
import org.springframework.web.multipart.MultipartFile
import org.zeroturnaround.zip.ZipUtil

interface ResourcesService {
    fun getRunReport(runId: String): Outcome<File>
    fun handleDumpUpload(file: MultipartFile): Outcome<String>
}

@Service("ResourcesService")
class ResourcesServiceImpl(
    @Value("\${touchstone.data-path}") private val touchstoneDataPath: String,

    private val imageService: ImageService,
    private val testRunService: TestRunService,

    private val objectMapper: ObjectMapper
) : ResourcesService {
    @ExperimentalPathApi
    override fun getRunReport(runId: String): Outcome<File> {
        val runResult = testRunService.findById(runId)
        when (runResult) {
            is Outcome.Success -> {}
            is Outcome.Error -> return Outcome.Error(runResult.reason)
        }

        val tempDir = createTempDirectory()
        val reportDir = Paths.get(tempDir.toString(), "report-$runId")

        val logsPath = reportDir.resolve(Path("logs"))
        val logsDir = File("$touchstoneDataPath/logs/$runId")
        if (logsDir.exists()) {
            logsDir.copyRecursively(logsPath.toFile())
        }

        val resultFile = reportDir.resolve(Path("run-$runId.txt")).toFile()
        resultFile.appendText(objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(runResult.data))

        val screenshotsPath = reportDir.resolve(Path("screenshots"))
        runResult.data.cases.forEach { case ->
            val casePath = Paths.get(screenshotsPath.toString(), case.id)
            casePath.toFile().mkdirs()
            case.scenarios.forEach { scenario ->
                scenario.steps.forEach { step ->
                    if (step.screenshot != null) {
                        when (val imageResult = imageService.getImage(step.screenshot)) {
                            is Outcome.Success -> {
                                val out = Paths.get(casePath.toString(), step.screenshot)
                                out.parent.toFile().mkdirs()
                                out.writeBytes(IOUtils.toByteArray(imageResult.data))
                            }
                        }
                    }
                }
            }
        }

        val zipFile = Paths.get(tempDir.toString(), "report-$runId.zip").toFile()
        ZipUtil.pack(reportDir.toFile(), zipFile)

        return Outcome.Success(zipFile)
    }

    override fun handleDumpUpload(file: MultipartFile): Outcome<String> =
        if (!file.originalFilename!!.endsWith(".bson.gz")) {
            Outcome.Error(
                reason = "Database dump must be generated by mongodump with a .bson.gz extension",
                exception = InvalidOperationException()
            )
        } else {
            val destination = File("$touchstoneDataPath/dumps/")
            destination.mkdirs()
            destination.listFiles()?.let { files ->
                if (files.any { it.name == file.originalFilename }) {
                    return Outcome.Error(
                        reason = "A database dump with this name already exists",
                        exception = InvalidOperationException()
                    )
                }
            }
            file.transferTo(Path.of(destination.absolutePath, file.originalFilename))
            Outcome.Success(file.originalFilename!!)
        }
}
